#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jul 20 09:07:59 2023

@author: sreekrishnaravishankar
"""

import math
import numpy as np
import matplotlib.pyplot as plt
from CoolProp.CoolProp import PropsSI as cp

#=====================================================================================================#
def colebrook_equation(Re, epsilon, D):
    f = 0.05                                                                    # Initial guess for friction factor
    error = 1                                                                   # Error threshold
    max_iterations = 10
    iterations = 0

    while (error > 1e-6) and (iterations < max_iterations):
        f_new = (-2 * math.log10((epsilon / (3.7 * D)) + (2.51 / (Re * math.sqrt(f))))) ** -2
        error = abs(f_new - f)
        f = f_new
        iterations = iterations + 1    
    friction_factor = f
    return friction_factor

def Reynolds_number(G, dx, viscosity):
    Re = (G * dx) / viscosity
    return Re

def Cp_fluid(P_x, rho_x):
    Cp = cp('C', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return Cp

def Speed_of_Sound(P_x,rho_x):
    a = cp('A', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return a
def Entropy(P_x,rho_x):
    S = cp('S', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return S

def Thermal_conducitvity(P_x, rho_x):
    k = cp('L', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return k

def Viscosity(P_x, rho_x):
    Viscosity = cp('V', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return Viscosity

def Prandtl_number(cp, mu, k):
    Prandtl_number = (cp * mu) / k
    return Prandtl_number

def Gnielinski(f_x, Re_x, Pr):
    Nu = ((f_x / 8) * (Re_x - 1000) * Pr) / (1 + 12.7 * ((f_x / 8) ** 0.5) * ((Pr ** (2 / 3)) - 1))
    return Nu

def Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P_new):
    v_x = 1 / rho_x
    spec_vol_new = (P_x - P_new + ((G ** 2) * v_x) * (1 - ((f_x * dx) / (2 * D)))) / (G ** 2)
    rho_new = 1 / spec_vol_new
    return rho_new

def Eqn_of_State(P_new, T):
    Rho_new = cp('D', 'P', P_new, 'T', T, 'Hydrogen')
    return Rho_new

def Error(P1,P2,T_out,P_x,rho_x,G,f_x,D,dx,i):
    rho1_EOS = Eqn_of_State(P1, T_out)
    rho2_EOS = Eqn_of_State(P2, T_out)
    rho_momentum1 = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P1)
    rho_momentum2 = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P2)
    Error1 = rho1_EOS - rho_momentum1
    Error2 = rho2_EOS - rho_momentum2
    P3 = P2 - (((P1-P2)*Error2)/(Error1-Error2))
    print(f"P2 is: {P2},{i}")
    print(f"P3 is {P3},{i}")
    rho3_EOS = Eqn_of_State(P3, T_out)          
    rho3_momentum = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P3)
    Error3 = abs(rho3_EOS - rho3_momentum)
    print(Error3)
    if (Error3 <1e-13) or (P2 == P3):
        print("I am here")
        return float(P3)
        quit()
    elif (i<20) or (P1 != P2):
        P1 = P2
        P2 = P3
        i = i+1
        P3 = Error(P1,P2,T_out,P_x,rho_x,G,f_x,D,dx,i)
    else:
        print("Soln P_xdx not found after 20 iterations")
    return float(P3)
    


    
T_surface = 1200
P_x = 45e5
T_x = 25
samples = 10000
mdot = 37.962
D = 10e-2
Epsilon = 0.3853e-6
A_pipe = math.pi * (D ** 2) / 4
G = mdot / A_pipe
rho_x = cp('D', 'P', P_x, 'T', T_x, 'Hydrogen')
vel_x = G / rho_x
dx = 0.01
L_pipe = 7.33
pipe_elements = L_pipe / dx
segment = 0.00
segment_array = np.zeros(int(pipe_elements))
P_x_array = np.zeros(int(pipe_elements))
T_x_array = np.zeros(int(pipe_elements))
vel_x_array = np.zeros(int(pipe_elements))
Speed_Sound_array = np.zeros(int(pipe_elements))
Mach_no_array = np.zeros(int(pipe_elements))
entropy_array = np.zeros(int(pipe_elements))
rho_x_array = np.zeros(int(pipe_elements))
current_index = 0

while ((segment < pipe_elements) and (current_index<pipe_elements)):
    Cp = Cp_fluid(P_x, rho_x)
    k = Thermal_conducitvity(P_x, rho_x)
    mu = Viscosity(P_x, rho_x)
    Pr = Prandtl_number(Cp, mu, k)
    Re_x = Reynolds_number(G, dx, mu)
    f_x = colebrook_equation(Re_x, Epsilon, D)
    Nu = Gnielinski(f_x, Re_x, Pr)
    h = k * Nu / D
    A_pipe_element = (math.pi * D) * dx
    T_out = T_surface - ((T_surface - T_x) * math.exp(-(h * A_pipe_element) / (mdot * Cp)))
    segment_array[current_index] = segment
    P_x_array[current_index] = P_x
    T_x_array[current_index] = T_x
    vel_x_array[current_index] = vel_x
    rho_x_array[current_index] = rho_x
    Speed_Sound_array[current_index]= Speed_of_Sound(P_x, rho_x)
    Mach_no_array[current_index]= vel_x_array[current_index]/Speed_Sound_array[current_index]
    entropy_array[current_index] = Entropy(P_x, rho_x)
    
    P1 = P_x-(0.5e5)
    P2 = P_x+(0.5e5)
    i = 0
    P_xdx = Error(P1,P2,T_out,P_x,rho_x,G,f_x,D,dx,i)
    rho_xdx = Eqn_of_State(P_xdx,T_out)
    vel_xdx = G/rho_xdx
    
    P_x = P_xdx
    rho_x = rho_xdx
    vel_x = vel_xdx
    T_x = T_out
    segment = segment + dx
    current_index = current_index+1

'''

change here after brkfast
    # for i in range(len(P_new)):                                                 #Pnew = keep vel head const
    #     rho_new[i] = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P_new[i])
    #     T_new[i] = Eqn_of_State(P_new[i], rho_new[i])
    #     error[i] = abs(T_new[i] - T_out)

    # for i in range(len(error)):
    #     index = np.argmin(error)
    # error_final = error[index]
    # P_final = P_new[index]
    # rho_final = rho_new[index]
    # vel_final = G / rho_final
'''        


        
plt.figure(1)

plt.plot(segment_array, P_x_array, label='P_x')
plt.xlabel('Segment')
plt.ylabel('P_x')
plt.legend()

plt.figure(2)
plt.plot(segment_array, T_x_array, label='T_x')
plt.xlabel('Segment')
plt.ylabel('T_x')
plt.legend()

plt.figure(3)
plt.plot(segment_array, vel_x_array, label='vel_x')
plt.xlabel('Segment')
plt.ylabel('vel_x')
plt.legend()

plt.figure(4)
plt.plot(segment_array, rho_x_array, label='rho_x')
plt.xlabel('Segment')
plt.ylabel('rho_x')
plt.legend()

plt.figure(5)
plt.plot(segment_array, Mach_no_array, label='Mach_no')
plt.xlabel('Segment')
plt.ylabel('Mach_no')
plt.legend()

plt.figure(6)
plt.plot(segment_array, entropy_array, label='entropy')
plt.xlabel('Segment')
plt.ylabel('entropy')
plt.legend()

plt.figure(7)
plt.plot(entropy_array, T_x_array, label='Rayleigh_Fanno line')
plt.xlabel('entropy')
plt.ylabel('Temperature')
plt.legend()



# Plotting the error_final along the segment variable
