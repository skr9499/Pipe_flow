# -*- coding: utf-8 -*-
"""
Created on Mon Jul 31 08:50:55 2023

@author: S335830
"""

import math
import numpy as np
import matplotlib.pyplot as plt
from CoolProp.CoolProp import PropsSI as cp

#=====================================================================================================#
def colebrook_equation(Re, epsilon, D):
    f = 0.05                                                                    # Initial guess for friction factor
    error = 1                                                                   # Error threshold
    max_iterations = 10
    iterations = 0

    while (error > 1e-6) and (iterations < max_iterations):
        f_new = (-2 * math.log10((epsilon / (3.7 * D)) + (2.51 / (Re * math.sqrt(f))))) ** -2
        error = abs(f_new - f)
        f = f_new
        iterations = iterations + 1    
    friction_factor = f
    return friction_factor

def Reynolds_number(G, dx, viscosity):
    Re = (G * dx) / viscosity
    return Re

def Cp_fluid(P_x, rho_x):
    Cp = cp('C', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return Cp

def Thermal_conducitvity(P_x, rho_x):
    k = cp('L', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return k

def Viscosity(P_x, rho_x):
    Viscosity = cp('V', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return Viscosity

def Prandtl_number(cp, mu, k):
    Prandtl_number = (cp * mu) / k
    return Prandtl_number

def Gnielinski(f_x, Re_x, Pr):
    Nu = ((f_x / 8) * (Re_x - 1000) * Pr) / (1 + 12.7 * ((f_x / 8) ** 0.5) * ((Pr ** (2 / 3)) - 1))
    return Nu

def Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P_new):
    v_x = 1 / rho_x
    spec_vol_new = (P_x - P_new + ((G ** 2) * v_x) * (1 - ((f_x * dx) / (2 * D)))) / (G ** 2)
    rho_new = 1 / spec_vol_new
    return rho_new

def Eqn_of_State(P_new, T):
    Rho_new = cp('D', 'P', P_new, 'T', T, 'Hydrogen')
    return Rho_new

def Error(P1,P2,T_out,P_x,rho_x,G,f_x,D,dx,i):
    rho1_EOS = Eqn_of_State(P1, T_out)
    rho2_EOS = Eqn_of_State(P2, T_out)
    rho_momentum1 = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P1)
    rho_momentum2 = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P2)
    Error1 = rho1_EOS - rho_momentum1
    Error2 = rho2_EOS - rho_momentum2
    P3 = P2 - (((P1-P2)*Error2)/(Error1-Error2))
    print(P3)
    rho3_EOS = Eqn_of_State(P3, T_out)          
    rho3_momentum = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P3)
    Error3 = abs(rho3_EOS - rho3_momentum)
    print(Error3)
    if i > 20:
        print("Soln P_xdx not found after 20 iterations")
        i = i+1
        return P3,i    
    elif i <20:
        i = i+1
        Error(P2,P3,T_out,P_x,rho_x,G,f_x,D,dx,i)
    elif Error3<1e-6:
        return P3



    
T_surface = 1200
P_x = 45e5
T_x = 25
samples = 10000
mdot = 37.962
D = 10e-2
Epsilon = 0.3853e-6
A_pipe = math.pi * (D ** 2) / 4
G = mdot / A_pipe
rho_x = cp('D', 'P', P_x, 'T', T_x, 'Hydrogen')
vel_x = G / rho_x
dx = 0.01
L_pipe = 5
pipe_elements = L_pipe / dx



Cp = Cp_fluid(P_x, rho_x)
k = Thermal_conducitvity(P_x, rho_x)
mu = Viscosity(P_x, rho_x)
Pr = Prandtl_number(Cp, mu, k)
Re_x = Reynolds_number(G, dx, mu)
f_x = colebrook_equation(Re_x, Epsilon, D)
Nu = Gnielinski(f_x, Re_x, Pr)
h = k * Nu / D
A_pipe_element = (math.pi * D) * dx
T_out = T_surface - ((T_surface - T_x) * math.exp(-(h * A_pipe_element) / (mdot * Cp)))


P1 = P_x-(0.5e5)
P2 = P_x+(0.5e5)
i = 0
P_xdx = Error(P1,P2,T_out,P_x,rho_x,G,f_x,D,dx,i)
rho_xdx = Eqn_of_State(P_xdx,T_out)
vel_xdx = G/rho_xdx
