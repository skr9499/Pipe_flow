Diffchecker logo
Diffchecker
Text
Images
PDF
Excel
Folders
Features
Desktop
Pricing
Sign in
Create an account
Download Diffchecker Desktop
Saved Diffs
You haven't saved any diffs yet.
Diff history
8 minutes ago
Clear
Diff history is cleared on refresh
ad
Mailchimp
Target your best customers and see up to 88% more revenue with Predictive Segments. Sign up today.
SIGN UP

Regular

Real-time

Split

Unified

Word

Character

Expanded

Collapsed

Tools
300 lines
-
9 Removals
Copy all
300 lines
+
10 Additions
Copy all
import math	
import numpy as np	
import matplotlib.pyplot as plt	
from CoolProp.CoolProp import PropsSI as cp	
from matplotlib import cm	
from matplotlib.colors import LogNorm	
from matplotlib import colors	
#=====================================================================================================#	
def colebrook_equation(Re, epsilon, D):	
    f = 0.05                                                                    # Initial guess for friction factor	
    error = 1                                                                   # Error threshold	
    max_iterations = 10	
    iterations = 0	
    while (error > 1e-6) and (iterations < max_iterations):	
        f_new = (-2 * math.log10((epsilon / (3.7 * D)) + (2.51 / (Re * math.sqrt(f))))) ** -2	
        error = abs(f_new - f)	
        f = f_new	
        iterations = iterations + 1    	
    friction_factor = f	
    return friction_factor	
def Reynolds_number(G, dx, viscosity):	
    Re = (G * dx) / viscosity	
    return Re	
def Viscosity(P_x, rho_x):	
    Viscosity = cp('V', 'P', P_x, 'D', rho_x, 'Hydrogen')	
    return Viscosity	
def Cp_fluid(P_x, rho_x):	
    Cp = cp('C', 'P', P_x, 'D', rho_x, 'Hydrogen')	
    return Cp	
def Speed_of_Sound(P_x,rho_x):	
    a = cp('A', 'P', P_x, 'D', rho_x, 'Hydrogen')	
    return a	
def Entropy(P_x,rho_x):	
    S = cp('S', 'P', P_x, 'D', rho_x, 'Hydrogen')	
    return S	
def Thermal_conducitvity(P_x, rho_x):	
    k = cp('L', 'P', P_x, 'D', rho_x, 'Hydrogen')	
    return k	
def Prandtl_number(cp, mu, k):	
    Prandtl_number = (cp * mu) / k	
    return Prandtl_number	
def Gnielinski(f_x, Re_x, Pr):	
    Nu = ((f_x / 8) * (Re_x - 1000) * Pr) / (1 + 12.7 * ((f_x / 8) ** 0.5) * ((Pr ** (2 / 3)) - 1))	
    return Nu	
def Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P_new):	
    v_x = 1 / rho_x	
    spec_vol_new = (P_x - P_new + ((G ** 2) * v_x) * (1 - ((f_x * dx) / (2 * D)))) / (G ** 2)	
    rho_new = 1 / spec_vol_new	
    return rho_new	
def Frictional_Headloss(rho_x, G, f_x, D, dx):	
    P_drop = f_x*(G**2)*(dx/D)/(2*rho_x)	
    return P_drop	
def Eqn_of_State(P_new, T):	
    Rho_new = cp('D', 'P', P_new, 'T', T, 'Hydrogen')	
    return Rho_new	
def Enthalpy(P,T):	
    H = cp('Hmass', 'P', P, 'T', T, 'Hydrogen')	
    return H	
def Error(P1,P2,T_out,P_x,rho_x,G,f_x,D,dx,i):	
    rho1_EOS = Eqn_of_State(P1, T_out)	
    rho2_EOS = Eqn_of_State(P2, T_out)	
    rho_momentum1 = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P1)	
    rho_momentum2 = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P2)	
    Error1 = rho1_EOS - rho_momentum1	
    Error2 = rho2_EOS - rho_momentum2	
    P3 = P2 - (((P1-P2)*Error2)/(Error1-Error2))	
    print(f"P3 is {P3},{i}")	
    rho3_EOS = Eqn_of_State(P3, T_out)          	
    rho3_momentum = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P3)	
    Error3 = abs(rho3_EOS - rho3_momentum)    	
    if Error3 < 1e-10 or i >= 25:	
        if i >= 25:	
            print(f"Error for P3 = {P3} after {i} iteration {Error3}")	
            return False	
        return P3	
    	
    return Error(P2,P3,T_out,P_x,rho_x,G,f_x,D,dx,i+1)	
def Energy_Eqn(h_x,G,rho_x):	
    h0 = h_x + ((G**2)/2*rho_x)	
    return h0	
 	
T_surface = 1200	
P_x = 23.78e5	
T_x = 25	
samples = 10000	
mdot = 37.962	
D = 6e-2	
Epsilon = 0.3853e-6	
A_pipe = math.pi * (D ** 2) / 4	
G = mdot / A_pipe	
rho_x = cp('D', 'P', P_x, 'T', T_x, 'Hydrogen')	
P_int = P_x +((G**2)/rho_x)	
vel_x = G / rho_x	
dx = 0.01	
L_pipe = 0.8	
pipe_elements = L_pipe / dx	
segment = 0.00	
segment_array = np.zeros(int(pipe_elements))	
P_x_array = np.zeros(int(pipe_elements))	
P_drop_array_friction = np.zeros(int(pipe_elements))	
T_x_array = np.zeros(int(pipe_elements))	
vel_x_array = np.zeros(int(pipe_elements))	
Re_x_array = np.zeros(int(pipe_elements))	
Viscosity_array = np.zeros(int(pipe_elements))	
Speed_Sound_array = np.zeros(int(pipe_elements))	
Mach_no_array = np.zeros(int(pipe_elements))	
entropy_array = np.zeros(int(pipe_elements))	
enthalpy_array = np.zeros(int(pipe_elements))	
h_array = np.zeros(int(pipe_elements))	
rho_x_array = np.zeros(int(pipe_elements))	
cp_array = np.zeros(int(pipe_elements))	
# h_stag_array = np.zeros(int(pipe_elements))	
# T0_array = np.zeros(int(pipe_elements))	
current_index = 0	
while ((segment < pipe_elements) and (current_index<pipe_elements)):	
    Cp = Cp_fluid(P_x, rho_x)	
    k = Thermal_conducitvity(P_x, rho_x)	
    mu = Viscosity(P_x, rho_x)	
    Pr = Prandtl_number(Cp, mu, k)	
    Re_x = Reynolds_number(G, dx, mu)	
    f_x = colebrook_equation(Re_x, Epsilon, D)	
    Nu = Gnielinski(f_x, Re_x, Pr)	
    h = k * Nu / D	
    A_pipe_element = (math.pi * D) * dx	
    T_out = T_surface - ((T_surface - T_x) * math.exp(-(h * A_pipe_element) / (mdot * Cp)))	
    segment_array[current_index] = segment	
    P_x_array[current_index] = P_x	
    T_x_array[current_index] = T_x	
    vel_x_array[current_index] = vel_x	
    rho_x_array[current_index] = rho_x	
    Re_x_array[current_index] = Re_x	
    Speed_Sound_array[current_index]= Speed_of_Sound(P_x, rho_x)	
    Mach_no_array[current_index]= vel_x_array[current_index]/Speed_Sound_array[current_index]	
    entropy_array[current_index] = Entropy(P_x, rho_x)	
    enthalpy_array[current_index] = Enthalpy(P_x,T_out)	
    h_array[current_index] = h	
    cp_array[current_index] = Cp	
    Viscosity_array[current_index] = mu	
    P_drop_array_friction[current_index] = Frictional_Headloss(rho_x, G, f_x, D, dx)	
    P1 = P_x-(0.5e5)	
    P2 = P_x+(0.5e5)	
    i = 0	
    P_xdx = Error(P1,P2,T_out,P_x,rho_x,G,f_x,D,dx,i)	
    rho_xdx = Eqn_of_State(P_xdx,T_out)	
    vel_xdx = G/rho_xdx	
    # h_stag_array[current_index]= Energy_Eqn(enthalpy_array[current_index], G, rho_x)	
    # T0_array[current_index] = cp('T', 'P', P_int, 'Hmass', h_stag_array[current_index], 'Hydrogen')	
    P_x = P_xdx	
    rho_x = rho_xdx	
    vel_x = vel_xdx	
    T_x = T_out	
    segment = segment + dx	
    current_index = current_index+1	
       	
P0 = P_xdx + (G**2/rho_xdx)   	
Friction_loss = sum(P_drop_array_friction)	
P_stag = P0 + Friction_loss	
plt.figure(1)	
plt.plot(segment_array, P_x_array, label='P_x')	
plt.title('Static Pressure Drop vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('P_x')	
plt.legend()	
plt.figure(2)	
plt.plot(segment_array, T_x_array, label='T_x')	
plt.title('Static Temperature vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('T_x')	
plt.legend()	
plt.figure(3)	
plt.plot(segment_array, vel_x_array, label='vel_x')	
plt.title('Velocity vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('vel_x')	
plt.legend()	
plt.figure(4)	
plt.plot(segment_array, rho_x_array, label='rho_x')	
plt.title('Static Density Drop vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('rho_x')	
plt.legend()	
plt.figure(5)	
plt.plot(segment_array, Mach_no_array, label='Mach_no')	
plt.title('Pipe Mach No vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('Mach_no')	
plt.legend()	
plt.figure(6)	
plt.plot(segment_array, Re_x_array, label='Reynolds Number')	
plt.title('Reynolds Number vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('Reynolds Number')	
plt.legend()	
plt.figure(7)	
plt.plot(segment_array, entropy_array, label='entropy')	
plt.title('Static Entropy vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('entropy')	
plt.legend()	
plt.figure(8)	
plt.plot(segment_array, enthalpy_array, label='enthalpy')	
plt.title('Static Enthalpy vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('enthalpy')	
plt.legend()	
plt.figure(9)	
plt.plot(entropy_array, T_x_array, label='Rayleigh_Fanno line')	
plt.title('Rayleigh_Fanno line')	
plt.xlabel('Entropy')	
plt.ylabel('Temperature')	
plt.legend()	
plt.figure(10)	
plt.plot(segment_array, h_array, label='Convective heat transfer')	
plt.title('Convective Heat Transfer vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('convective heat transfer')	
plt.legend()	
plt.figure(11)	
plt.plot(enthalpy_array, entropy_array, label='Mollier')	
plt.title('Enthalpy vs Entropy')	
plt.xlabel('Entropy')	
plt.ylabel('Enthalpy')	
plt.legend()	
plt.figure(12)	
plt.plot(segment_array, P_drop_array_friction, label='Frictional drop in 1 cm pipe')	
plt.title('Fricitional Drop vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('Frictional drop (Pa)')	
plt.legend()	
plt.figure(13)	
plt.plot(segment_array, cp_array, label='Cp_array')	
plt.title('Specific Heat Const Pressure vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('Cp_array')	
plt.legend()	
plt.figure(14)	
plt.plot(segment_array, Viscosity_array, label='Viscosity_array')	
plt.title('Viscosity vs Pipe Length')	
plt.xlabel('Pipe Length')	
plt.ylabel('Viscosity_array')	
plt.legend()	
plt.figure(15)	
custom_breakpoints = np.linspace(min(rho_x_array),max(rho_x_array),10)	
cmap = plt.get_cmap('plasma')	
norm = colors.BoundaryNorm(custom_breakpoints, cmap.N)	
# Create the scatter plot with custom color map and norm	
fig, ax = plt.subplots()	
sc = ax.scatter(T_x_array, P_x_array, c=rho_x_array, cmap=cmap, norm=norm)	
plt.title('Density Change vs Pipe Length')	
# Set axis labels	
ax.set_xlabel('Temperature (K)')	
ax.set_ylabel('Pressure (Pa)')	
# Add a colorbar to indicate density values	
cbar = plt.colorbar(sc)	
cbar.set_label('Density')	
Editor
Compare & merge
Clear
Export as PDF
Save DiffShare
No file chosen
Original Text
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jul 20 09:07:59 2023

@author: sreekrishnaravishankar
"""

import math
import numpy as np
import matplotlib.pyplot as plt
from CoolProp.CoolProp import PropsSI as cp
from matplotlib import cm
from matplotlib.colors import LogNorm
from matplotlib import colors
#=====================================================================================================#
def colebrook_equation(Re, epsilon, D):
    f = 0.05                                                                    # Initial guess for friction factor
    error = 1                                                                   # Error threshold
    max_iterations = 10
    iterations = 0

    while (error > 1e-6) and (iterations < max_iterations):
        f_new = (-2 * math.log10((epsilon / (3.7 * D)) + (2.51 / (Re * math.sqrt(f))))) ** -2
        error = abs(f_new - f)
        f = f_new
        iterations = iterations + 1    
    friction_factor = f
    return friction_factor

def Reynolds_number(G, dx, viscosity):
    Re = (G * dx) / viscosity
    return Re

def Viscosity(P_x, rho_x):
    Viscosity = cp('V', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return Viscosity

def Cp_fluid(P_x, rho_x):
    Cp = cp('C', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return Cp

def Speed_of_Sound(P_x,rho_x):
    a = cp('A', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return a
def Entropy(P_x,rho_x):
    S = cp('S', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return S

def Thermal_conducitvity(P_x, rho_x):
    k = cp('L', 'P', P_x, 'D', rho_x, 'Hydrogen')
    return k

def Prandtl_number(cp, mu, k):
    Prandtl_number = (cp * mu) / k
    return Prandtl_number

def Gnielinski(f_x, Re_x, Pr):
    Nu = ((f_x / 8) * (Re_x - 1000) * Pr) / (1 + 12.7 * ((f_x / 8) ** 0.5) * ((Pr ** (2 / 3)) - 1))
    return Nu

def Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P_new):
    v_x = 1 / rho_x
    spec_vol_new = (P_x - P_new + ((G ** 2) * v_x) * (1 - ((f_x * dx) / (2 * D)))) / (G ** 2)
    rho_new = 1 / spec_vol_new
    return rho_new

def Frictional_Headloss(rho_x, G, f_x, D, dx):
    P_drop = f_x*(G**2)*(dx/D)/(2*rho_x)
No file chosen
Changed Text
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
    rho3_EOS = Eqn_of_State(P3, T_out)          
    rho3_momentum = Momentum_Eqn(P_x, rho_x, G, f_x, D, dx, P3)
    Error3 = abs(rho3_EOS - rho3_momentum)  
    print(f" P3 = {P3} after {i} iteration {Error3}")
    if Error3 < 1e-10 or i >= 20:
        if i >= 20:
            print(f"Error for P3 = {P3} after {i} iteration {Error3}")
            return False
        return P3
    
    return Error(P2,P3,T_out,P_x,rho_x,G,f_x,D,dx,i+1)

def Energy_Eqn(h_x,G,rho_x):
    h0 = h_x + ((G**2)/2*rho_x)
    return h0


 
T_surface = 1200
P_x = 23.78e5
T_x = 25
samples = 10000
mdot = 37.962
D = 6e-2
Epsilon = 0.3853e-6
A_pipe = math.pi * (D ** 2) / 4
G = mdot / A_pipe
rho_x = cp('D', 'P', P_x, 'T', T_x, 'Hydrogen')
P_int = P_x +((G**2)/rho_x)
vel_x = G / rho_x
dx = 0.01
L_pipe = 0.8
pipe_elements = L_pipe / dx
segment = 0.00
segment_array = np.zeros(int(pipe_elements))
P_x_array = np.zeros(int(pipe_elements))
P_drop_array_friction = np.zeros(int(pipe_elements))
T_x_array = np.zeros(int(pipe_elements))
vel_x_array = np.zeros(int(pipe_elements))
Re_x_array = np.zeros(int(pipe_elements))
Viscosity_array = np.zeros(int(pipe_elements))
Speed_Sound_array = np.zeros(int(pipe_elements))
Mach_no_array = np.zeros(int(pipe_elements))
entropy_array = np.zeros(int(pipe_elements))
enthalpy_array = np.zeros(int(pipe_elements))
h_array = np.zeros(int(pipe_elements))
rho_x_array = np.zeros(int(pipe_elements))
cp_array = np.zeros(int(pipe_elements))
# h_stag_array = np.zeros(int(pipe_elements))
# T0_array = np.zeros(int(pipe_elements))
current_index = 0

while ((segment < pipe_elements) and (current_index<pipe_elements)):
    Cp = Cp_fluid(P_x, rho_x)
    k = Thermal_conducitvity(P_x, rho_x)
    mu = Viscosity(P_x, rho_x)
    Pr = Prandtl_number(Cp, mu, k)
    Re_x = Reynolds_number(G, dx, mu)
    f_x = colebrook_equation(Re_x, Epsilon, D)
    Nu = Gnielinski(f_x, Re_x, Pr)
    h = k * Nu / D
    A_pipe_element = (math.pi * D) * dx
    T_out = T_surface - ((T_surface - T_x) * math.exp(-(h * A_pipe_element) / (mdot * Cp)))
    segment_array[current_index] = segment
    P_x_array[current_index] = P_x
    T_x_array[current_index] = T_x
    vel_x_array[current_index] = vel_x
    rho_x_array[current_index] = rho_x
    Re_x_array[current_index] = Re_x
    Speed_Sound_array[current_index]= Speed_of_Sound(P_x, rho_x)
    Mach_no_array[current_index]= vel_x_array[current_index]/Speed_Sound_array[current_index]
    entropy_array[current_index] = Entropy(P_x, rho_x)
    enthalpy_array[current_index] = Enthalpy(P_x,T_out)
    h_array[current_index] = h
cbar.set_label('Density')
ad
Be open, be sustainable, be free in the cloud
Spend less time asking questions on forums. Try our hassle-free server deployment
LEARN MORE
ad
Get the advanced tools you need to grow
Get suggestions for improving your content, targeting, and marketing automations to help you increase revenue.
SIGN UP
Find Difference
ads via Carbon
Meet the future of frontend. Zero configuration for 35+ frameworks. Take our interactive tour today.
ads via Carbon
© 2023 Checker Software Inc.ContactCLITermsPrivacy PolicyAPIOlder Compare Text
EnglishFrançaisEspañolPortuguêsItalianoDeutschहिन्दी简体繁體日本語
