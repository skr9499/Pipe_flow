#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Oct 17 10:58:52 2023

@author: sreekrishnaravishankar
"""

import numpy as np
import matplotlib.pyplot as plt
import math
from CoolProp.CoolProp import PropsSI as cp
import CoolProp.CoolProp as CP

def Eqn_of_State(P_x, T_x):
    Rho = cp('D', 'P', P_x, 'T', T_x, 'Hydrogen')
    Rho_inv = 1/Rho
    return Rho_inv

def Enthalpy(P_x,T_x):
    H = cp('Hmass', 'P', P_x, 'T', T_x, 'Hydrogen')
    return H

def Energy_Eqn(h0,P_x,T_x,G):
    # print(f"This is P_x {P_x} and T_x is {T_x} at Energy Eqn")
    f1_without_array = h0 - Enthalpy(P_x, T_x) - (0.5*(G*Eqn_of_State(P_x, T_x))**2)
    f1 = np.array([f1_without_array])
    # print(f"This is f1 {f1}")
    return f1

def H_diff_wrt_P(P_x,T_x):
    HdiffP=CP.PropsSI('d(Hmass)/d(P)|T','P',P_x,'T',T_x,'Hydrogen')
    return HdiffP

def H_diff_wrt_T(P_x,T_x):
    HdiffT=CP.PropsSI('d(Hmass)/d(T)|P','P',P_x,'T',T_x,'Hydrogen')
    return HdiffT

def Pressure_Eqn(P0,P_x,T_x,G):
    # print(f"This is P_x {P_x} and T_x is {T_x} at Pressure Eqn")
    f2 = P0 - P_x - ((G**2)*(Eqn_of_State(P_x, T_x)))
    # print(f"This is f2 {f2}")
    return f2

def D_diff_wrt_T(P_x,T_x):
    DdiffT = CP.PropsSI('d(D)/d(T)|P','P',P_x,'T',T_x,'Hydrogen')
    return DdiffT

def D_diff_wrt_P(P_x,T_x):
    DdiffP = CP.PropsSI('d(D)/d(P)|T','P',P_x,'T',T_x,'Hydrogen')
    return DdiffP

def Energy_diff_wrt_P(P_x,T_x,G):
    f1diffP = ((G**2)*((Eqn_of_State(P_x, T_x))**3)*(D_diff_wrt_P(P_x, T_x)))-H_diff_wrt_P(P_x, T_x)
    return f1diffP

def Energy_diff_wrt_T(P_x,T_x,G):
    f1diffT = ((G**2)*((Eqn_of_State(P_x, T_x))**3)*(D_diff_wrt_T(P_x, T_x)))-H_diff_wrt_T(P_x, T_x)
    return f1diffT

def Pressure_diff_wrt_P(P_x,T_x,G):
    f2diffP = (((G*Eqn_of_State(P_x, T_x))**2)*D_diff_wrt_P(P_x, T_x))-1
    return f2diffP

def Pressure_diff_wrt_T(P_x,T_x,G):
    f2diffT = (((G*Eqn_of_State(P_x, T_x))**2)*D_diff_wrt_T(P_x, T_x))
    return f2diffT

def Jacobian(x_n,G):
    P_x = x_n[0, :]
    T_x = x_n[1, :]
    f1diffP = Energy_diff_wrt_P(P_x, T_x, G)
    f1diffT = Energy_diff_wrt_T(P_x, T_x, G)
    f2diffP = Pressure_diff_wrt_P(P_x, T_x, G)
    f2diffT = Pressure_diff_wrt_T(P_x, T_x, G)
    J_Matrix = np.array([[f1diffP,f1diffT],[f2diffP,f2diffT]])
    J_inv = np.linalg.inv(J_Matrix)
    # print(f"This is Inv Jaco {J_inv}")
    return J_inv

def Func_vector(P0,h0,G,x_n):
    P_x = x_n[0, :]
    T_x = x_n[1, :]
    F = np.array([Energy_Eqn(h0, P_x, T_x, G),Pressure_Eqn(P0, P_x, T_x, G)])
    # print(f"This is F vector {F}")
    return F

def NewtonRaphson(P0,h0,P_x,T_x,G):
    x_n = np.array([[P_x],[T_x]])
    for iteration in range(1000):
        # print(f"This is iteration {iteration}")
        x_n_1 = x_n - np.dot(Jacobian(x_n, G),Func_vector(P0, h0, G, x_n))
        # print(f"This is new inlet vector {x_n_1}")
        Error_Matrix = (x_n_1-x_n)
        if (Error_Matrix.all()<1e-7):
            # print(f"This is new inlet vector {x_n_1} and correspnding error is {Error_Matrix}")
            break
        x_n=x_n_1
    else:
        print("Solution did not converge within 1000 iterations.")
        
    return x_n_1

P0 = 50e5
T0 = 25
mdot = 40
Dia_Pipe = 10e-2
L_pipe = 23.19
dx = 0.01
Area_Pipe = math.pi*(Dia_Pipe**2)/4
G = mdot/Area_Pipe
h0 = cp('Hmass', 'P', P0, 'T', T0, 'Hydrogen')
Stag_P_x_array= P0
Stag_T_x_array=T0
Stag_rho_x_array  = 1/Eqn_of_State(P0, T0) 
P_x = P0-0.5e5
T_x = T0-2  
Inlet_Field = NewtonRaphson(P0, h0, P_x, T_x, G)
Stat_P_x_array = Inlet_Field[0,:]
Stat_T_x_array = Inlet_Field[1,:]
